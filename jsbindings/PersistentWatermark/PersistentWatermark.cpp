/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2023 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

#include "PersistentWatermark.h"
#include "jsutils.h"

#ifndef USE_WATERMARK_JSBINDINGS

void PersistentWatermark_LoadJS(void* context)
{
    LOG_WARN_EX("PersistentWatermark: JS bindings not registered.");
};
#else

#include <mutex>
/*
	Do not allow concurrency in the PersistentWatermark API
	There is no requirement for it and
	eliminating it greatly simplifies design and validation
*/
static std::mutex JSInterfaceMutex;

#ifndef USE_CPP_THUNDER_PLUGIN_ACCESS
	#error "thunder plugin access required"
#endif

#include "PersistentWatermarkDisplaySequencer.h"

/**
 @brief
 * Checks argumentCount against expectedArgumentCount & provides standard logging.
 * returns true where argumentCount>=expectedArgumentCount*/
static bool ArgumentCheck(size_t argumentCount, size_t expectedArgumentCount, const char* functionName)
{
	std::string msg = "PersistentWatermark: ";
	 msg+=functionName;
	msg+=": argumentCount (";
	msg+=std::to_string(argumentCount);
	msg+=") ";

	bool success = true;
	if(argumentCount==expectedArgumentCount) msg+="=";
	else if(argumentCount>expectedArgumentCount) msg+=">";
	else
	{
		msg+="<";
		success = false;
	}

	msg+=" expectedArgumentCount (";
	msg+=std::to_string(expectedArgumentCount);
	msg+=")";

	if(success)
	{
		LOG_TRACE(msg.c_str());
	}
	else
	{
		LOG_ERROR_EX(msg.c_str());
	}

	return success;
}

/**
 @brief JS update() method - stores the image and metadata supplied by JS
 */
static JSValueRef PersistentWatermarkJS_Update (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	LOG_WARN_EX("PersistentWatermark.Update()");

	if (!ArgumentCheck(argumentCount, 2, __FUNCTION__))
	{
		//error message generated by ArgumentCheck if necessary
		return JSValueMakeBoolean(ctx, false);
	}
	return PersistentWatermark::Storage::getInstance().Update(ctx, function, thisObject, argumentCount, arguments, exception);
}

/**
 @brief JS getMetadata() method - returns stored metadata to JS (or "" if none is stored)
 */
static JSValueRef PersistentWatermarkJS_getMetadata (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	LOG_WARN_EX("PersistentWatermark.getMetadata()");
	std::string metaDataStr = PersistentWatermark::Storage::getInstance().getMetadata();
	const char* metaData = metaDataStr.c_str();
	LOG_WARN_EX("successs metadata:%s",metaData);
	return aamp_CStringToJSValue(ctx, metaData);
}

/**
 @brief JS Hide() method - hides any watermark currently displayed
 */
static JSValueRef PersistentWatermarkJS_Hide (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	LOG_WARN_EX("PersistentWatermark.Hide()");
	PersistentWatermark::DisplaySequencer::getInstance().Hide();
	LOG_TRACE("PersistentWatermark.Hide() Exit");
	return JSValueMakeUndefined(ctx);
}

/**
 @brief JS Show() method - displays a watermark if one is stored
 */
static JSValueRef PersistentWatermarkJS_Show (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	int iOpacityValue = 100;
	// read the opacity value if present
	if (argumentCount == 1 )
	{
		iOpacityValue = (int) JSValueToNumber(ctx, arguments[0], NULL);
	}
	LOG_WARN_EX("PersistentWatermark.Show() with opacity %d", iOpacityValue);
	PersistentWatermark::DisplaySequencer::getInstance().Show(PersistentWatermark::Storage::getInstance(),iOpacityValue);
	LOG_TRACE("PersistentWatermark.Show() Exit");
	return JSValueMakeUndefined(ctx);
}

/**
 @brief JS addEventListener() method - registers a callback for the specified event
 */
static JSValueRef PersistentWatermarkJS_addEventListener (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	LOG_WARN_EX("PersistentWatermark.addEventListener()");
	if (!ArgumentCheck(argumentCount, 2, __FUNCTION__))
	{
		//error message generated by ArgumentCheck if necessary
		return JSValueMakeBoolean(ctx, false);
	}

	JSObjectRef callback = JSValueToObject(ctx, arguments[1], NULL);
	if (callback == NULL)
	{
		LOG_ERROR_EX("PersistentWatermark:null callback");
		return JSValueMakeBoolean(ctx, false);
	}

	if (!JSObjectIsFunction(ctx, callback))
	{
		LOG_ERROR_EX("PersistentWatermark: callback is not a function");
		return JSValueMakeBoolean(ctx, false);
	}

	if(!JSValueIsString(ctx, arguments[0]))
	{
		LOG_ERROR_EX("PersistentWatermark: Argument 1 is not a string.");
		return JSValueMakeBoolean(ctx, false);
	}

	std::string eventName = aamp_JSValueToCString(ctx, arguments[0], NULL);
	bool success = PersistentWatermark::EventHandler::getInstance().addEventHandler(eventName, callback, ctx);
	if(success)
	{
		LOG_WARN_EX("PersistentWatermark:success");
	}
	else
	{
		LOG_ERROR_EX("PersistentWatermark:failed");
	}
	return JSValueMakeBoolean(ctx, success);
}

/**
 @brief JS RemoveEventListener() method - removes callbacks for the specified event
 */
static JSValueRef PersistentWatermarkJS_RemoveEventListener(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	LOG_WARN_EX("PersistentWatermark.RemoveEventListener()");

	if (!ArgumentCheck(argumentCount, 1, __FUNCTION__))
	{
		//error message generated by ArgumentCheck if necessary
		return JSValueMakeNumber(ctx, 0);
	}

	if(!JSValueIsString(ctx, arguments[0]))
	{
		LOG_ERROR_EX("PersistentWatermark: Argument 1 is not a string.");
		return JSValueMakeNumber(ctx, 0);
	}

	std::string eventName = aamp_JSValueToCString(ctx, arguments[0], NULL);
	int removed =  PersistentWatermark::EventHandler::getInstance().RemoveEventHandler(eventName);
	LOG_WARN_EX("PersistentWatermark: success Removed %d handlers for %s event.", removed, eventName.c_str());
	return JSValueMakeNumber(ctx,removed);
}

static const JSStaticFunction PersistentWatermark_JS_static_functions[] = {
	{ "Update", PersistentWatermarkJS_Update, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ "Hide", PersistentWatermarkJS_Hide, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ "Show", PersistentWatermarkJS_Show, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ "addEventListener", PersistentWatermarkJS_addEventListener, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ "RemoveEventListener", PersistentWatermarkJS_RemoveEventListener, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ "getMetadata", PersistentWatermarkJS_getMetadata, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly},
	{ NULL, NULL, 0 },
};

static constexpr const char* PERSISTENT_WATERMARK_VERSION = "0.3";

static JSValueRef getProperty_Version(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
{
	LOG_TRACE("Enter/exit");
	return aamp_CStringToJSValue(ctx, PERSISTENT_WATERMARK_VERSION);
}

static const JSStaticValue PersistentWatermark_JS_static_values[] = {
	{ "version", getProperty_Version, NULL, kJSPropertyAttributeDontDelete | kJSPropertyAttributeReadOnly },
	{ NULL, NULL, NULL, 0 }
};

static JSClassDefinition PersistentWatermark_JS_object_def {
	0, /* current (and only) version is 0 */
	kJSClassAttributeNone,
	"__PersistentWatermark",
	NULL,
	PersistentWatermark_JS_static_values,
	PersistentWatermark_JS_static_functions,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};

static JSClassRef PersistentWatermark_object_ref() {
	static JSClassRef _ObjRef = NULL;
	if (!_ObjRef) {
		_ObjRef = JSClassCreate(&PersistentWatermark_JS_object_def);
	}
	return _ObjRef;
}

static JSObjectRef PersistentWatermark_JS_class_constructor(JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
	LOG_TRACE("Enter");
	static JSObjectRef newObj = JSObjectMake(ctx, PersistentWatermark_object_ref(), NULL);
	LOG_TRACE("Exit");
	return newObj;
}

static JSClassDefinition PersistentWatermark_JS_class_def {
	0, /* current (and only) version is 0 */
	kJSClassAttributeNone,
	"__PersistentWatermark__class",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	PersistentWatermark_JS_class_constructor,
	NULL,
	NULL
};

void PersistentWatermark_LoadJS(void* context)
{
	LOG_TRACE("Enter");
	std::lock_guard<std::mutex>lock(JSInterfaceMutex);
	JSGlobalContextRef jsContext = (JSGlobalContextRef)context;
	JSObjectRef globalObj = JSContextGetGlobalObject(jsContext);

	LOG_WARN_EX("PersistentWatermark:register persistent watermark class version %s", PERSISTENT_WATERMARK_VERSION);
	JSClassRef PersistentWatermarkClass = JSClassCreate(&PersistentWatermark_JS_class_def);
	JSObjectRef PersistentWatermarkClassObj = JSObjectMakeConstructor(jsContext, PersistentWatermarkClass, PersistentWatermark_JS_class_constructor);
	JSValueProtect(jsContext, PersistentWatermarkClassObj);

	JSStringRef namestr = JSStringCreateWithUTF8CString("PersistentWatermark");
	JSObjectSetProperty(jsContext, globalObj, namestr, PersistentWatermarkClassObj, kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete, NULL);
	JSClassRelease(PersistentWatermarkClass);
	JSStringRelease(namestr);
	LOG_WARN_EX("PersistentWatermark:done with registering persistent watermark class version %s", PERSISTENT_WATERMARK_VERSION);
	LOG_TRACE("Exit");
};
#endif
